package inference

import (
	"testing"

	"github.com/modern-tooling/aloc/internal/model"
)

func TestPathRules_NotEmpty(t *testing.T) {
	if len(PathRules) == 0 {
		t.Error("PathRules should not be empty")
	}
}

func TestPathRules_ValidRoles(t *testing.T) {
	validRoles := make(map[model.Role]bool)
	for _, r := range model.AllRoles {
		validRoles[r] = true
	}

	for _, rule := range PathRules {
		if !validRoles[rule.Role] {
			t.Errorf("PathRule has invalid role: %v", rule.Role)
		}
		if rule.Fragment == "" {
			t.Error("PathRule has empty fragment")
		}
		if rule.Weight <= 0 || rule.Weight > 1.0 {
			t.Errorf("PathRule weight out of range: %v", rule.Weight)
		}
	}
}

func TestPathRules_ContainsExpectedFragments(t *testing.T) {
	expected := []string{
		"/test/",
		"/tests/",
		"/vendor/",
		"/node_modules/",
		"/docs/",
		"/infra/",
		"/terraform/",
	}

	fragments := make(map[string]bool)
	for _, rule := range PathRules {
		fragments[rule.Fragment] = true
	}

	for _, exp := range expected {
		if !fragments[exp] {
			t.Errorf("PathRules missing expected fragment: %s", exp)
		}
	}
}

func TestFilenameRules_NotEmpty(t *testing.T) {
	if len(FilenameRules) == 0 {
		t.Error("FilenameRules should not be empty")
	}
}

func TestFilenameRules_ValidMatchTypes(t *testing.T) {
	validMatchTypes := map[string]bool{
		"suffix":   true,
		"prefix":   true,
		"contains": true,
	}

	for _, rule := range FilenameRules {
		if !validMatchTypes[rule.MatchType] {
			t.Errorf("FilenameRule has invalid match type: %v", rule.MatchType)
		}
		if rule.Pattern == "" {
			t.Error("FilenameRule has empty pattern")
		}
		if rule.Weight <= 0 || rule.Weight > 1.0 {
			t.Errorf("FilenameRule weight out of range: %v", rule.Weight)
		}
	}
}

func TestFilenameRules_TestPatternsHaveSubRole(t *testing.T) {
	for _, rule := range FilenameRules {
		if rule.Role == model.RoleTest {
			// Test rules should have SubRole set
			if rule.SubRole == "" {
				t.Errorf("Test FilenameRule missing SubRole: pattern=%s", rule.Pattern)
			}
		}
	}
}

func TestFilenameRules_ContainsExpectedPatterns(t *testing.T) {
	expected := []string{
		"_test.",
		".spec.",
		"dockerfile",
		"readme",
	}

	patterns := make(map[string]bool)
	for _, rule := range FilenameRules {
		patterns[rule.Pattern] = true
	}

	for _, exp := range expected {
		if !patterns[exp] {
			t.Errorf("FilenameRules missing expected pattern: %s", exp)
		}
	}
}

func TestExtensionRules_NotEmpty(t *testing.T) {
	if len(ExtensionRules) == 0 {
		t.Error("ExtensionRules should not be empty")
	}
}

func TestExtensionRules_ValidExtensions(t *testing.T) {
	for _, rule := range ExtensionRules {
		if rule.Ext == "" {
			t.Error("ExtensionRule has empty extension")
		}
		if rule.Ext[0] != '.' {
			t.Errorf("ExtensionRule extension should start with dot: %v", rule.Ext)
		}
		if rule.Weight <= 0 || rule.Weight > 1.0 {
			t.Errorf("ExtensionRule weight out of range: %v", rule.Weight)
		}
	}
}

func TestExtensionRules_ContainsExpectedExtensions(t *testing.T) {
	expected := []string{
		".md",
		".yaml",
		".yml",
		".lock",
		".pb.go",
		".proto",
	}

	extensions := make(map[string]bool)
	for _, rule := range ExtensionRules {
		extensions[rule.Ext] = true
	}

	for _, exp := range expected {
		if !extensions[exp] {
			t.Errorf("ExtensionRules missing expected extension: %s", exp)
		}
	}
}

func TestHeaderRules_NotEmpty(t *testing.T) {
	if len(HeaderRules) == 0 {
		t.Error("HeaderRules should not be empty")
	}
}

func TestHeaderRules_ValidPatterns(t *testing.T) {
	for _, rule := range HeaderRules {
		if rule.Pattern == "" {
			t.Error("HeaderRule has empty pattern")
		}
		if rule.Weight <= 0 || rule.Weight > 1.0 {
			t.Errorf("HeaderRule weight out of range: %v", rule.Weight)
		}
	}
}

func TestHeaderRules_ContainsExpectedPatterns(t *testing.T) {
	expected := []string{
		"Code generated by",
		"DO NOT EDIT",
		"@generated",
		"func Test",
	}

	patterns := make(map[string]bool)
	for _, rule := range HeaderRules {
		patterns[rule.Pattern] = true
	}

	for _, exp := range expected {
		if !patterns[exp] {
			t.Errorf("HeaderRules missing expected pattern: %s", exp)
		}
	}
}

func TestPathRules_VendorHighWeight(t *testing.T) {
	// Vendor rules should have high weight
	vendorFragments := []string{"/vendor/", "/third_party/", "/node_modules/"}

	for _, rule := range PathRules {
		for _, frag := range vendorFragments {
			if rule.Fragment == frag {
				if rule.Weight < 0.90 {
					t.Errorf("Vendor rule %s should have weight >= 0.90, got %v", frag, rule.Weight)
				}
			}
		}
	}
}

func TestFilenameRules_InfraFilesHighWeight(t *testing.T) {
	// Dockerfile and docker-compose should have high weight
	infraPatterns := []string{"dockerfile", "docker-compose"}

	for _, rule := range FilenameRules {
		for _, pat := range infraPatterns {
			if rule.Pattern == pat && rule.Role == model.RoleInfra {
				if rule.Weight < 0.80 {
					t.Errorf("Infra rule %s should have weight >= 0.80, got %v", pat, rule.Weight)
				}
			}
		}
	}
}

func TestExtensionRules_LockFilesHighWeight(t *testing.T) {
	for _, rule := range ExtensionRules {
		if rule.Ext == ".lock" {
			if rule.Weight < 0.90 {
				t.Errorf(".lock extension should have weight >= 0.90, got %v", rule.Weight)
			}
			if rule.Role != model.RoleGenerated {
				t.Errorf(".lock extension should be generated, got %v", rule.Role)
			}
		}
	}
}

func TestHeaderRules_GeneratedMarkersHighWeight(t *testing.T) {
	generatedPatterns := []string{"Code generated by", "DO NOT EDIT", "@generated"}

	for _, rule := range HeaderRules {
		for _, pat := range generatedPatterns {
			if rule.Pattern == pat && rule.Role == model.RoleGenerated {
				if rule.Weight < 0.85 {
					t.Errorf("Generated header rule %s should have weight >= 0.85, got %v", pat, rule.Weight)
				}
			}
		}
	}
}
